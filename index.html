<!doctype html>
<html lang="de">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Java MC-Quiz – 12 aus 100 (Probeklausur-Stil)</title>
    <style>
        body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;margin:0;padding:24px;background:#f6f7fb;color:#0f172a}
        .app{max-width:980px;margin:0 auto;background:#fff;border-radius:16px;box-shadow:0 12px 30px rgba(2,8,23,.08);overflow:hidden}
        header{padding:18px 20px;background:linear-gradient(135deg,#0ea5e9,#6366f1);color:#fff;display:flex;align-items:center;justify-content:space-between;gap:12px}
        header h1{font-size:16px;margin:0;font-weight:800}
        header .meta{font-size:13px;opacity:.95}
        main{padding:20px}
        .row{display:flex;flex-wrap:wrap;gap:10px;align-items:center;justify-content:space-between;margin-bottom:16px}
        .pill{display:inline-flex;align-items:center;gap:8px;background:#eef2ff;color:#3730a3;border:1px solid #e0e7ff;padding:8px 12px;border-radius:999px;font-size:13px;font-weight:700}
        .progress{flex:1;min-width:220px;height:10px;background:#e5e7eb;border-radius:999px;overflow:hidden}
        .progress>div{height:100%;width:0%;background:#22c55e;transition:width .25s ease}
        .card{border:1px solid #e5e7eb;border-radius:14px;padding:16px;background:#fff}
        .q-title{margin:0 0 10px 0;font-size:16px;font-weight:900}
        pre{background:#0b1220;color:#e5e7eb;padding:12px 14px;border-radius:12px;overflow:auto;margin:10px 0 14px 0;font-size:13px;line-height:1.35}
        .options{display:grid;gap:10px;margin-top:8px}
        .opt{border:1px solid #e5e7eb;border-radius:12px;padding:10px 12px;display:flex;gap:10px;align-items:flex-start;cursor:pointer;user-select:none;transition:border-color .15s ease,background .15s ease}
        .opt:hover{border-color:#cbd5e1;background:#f8fafc}
        .opt input{margin-top:2px}
        .opt.correct{border-color:#16a34a;background:#f0fdf4}
        .opt.wrong{border-color:#dc2626;background:#fef2f2}
        .feedback{margin-top:14px;padding:12px 12px;border-radius:12px;border:1px solid #e5e7eb;background:#f8fafc;display:none}
        .feedback.ok{border-color:#16a34a;background:#f0fdf4}
        .feedback.no{border-color:#dc2626;background:#fef2f2}
        .btnbar{display:flex;gap:10px;margin-top:14px;flex-wrap:wrap}
        button{border:0;border-radius:12px;padding:10px 14px;font-weight:800;cursor:pointer;background:#111827;color:#fff}
        button.secondary{background:#e5e7eb;color:#111827}
        button:disabled{opacity:.55;cursor:not-allowed}
        .result{display:none;border:1px solid #e5e7eb;border-radius:14px;padding:16px;background:#fff}
        .result h2{margin:0 0 8px 0;font-size:18px}
        .review{margin-top:12px;display:grid;gap:10px}
        .review .item{border:1px solid #e5e7eb;border-radius:12px;padding:12px;background:#f8fafc}
        .small{font-size:13px;color:#334155}
        footer{padding:14px 20px;font-size:12px;color:#64748b;background:#f8fafc}
    </style>
</head>
<body>
<div class="app">
    <header>
        <div>
            <h1>Java MC-Quiz – 12 aus 100 (Probeklausur-Stil)</h1>
            <div class="meta">Random 12 Fragen pro Durchlauf • Single-Select • Sofort-Feedback</div>
        </div>
        <div class="meta"><b>Themen:</b> Operatoren • Kontrollfluss • Arrays • OOP • Semiotik</div>
    </header>

    <main>
        <div class="row">
            <div class="pill">Frage: <span id="qIndex">1</span>/<span id="qTotal">12</span></div>
            <div class="pill">Punkte: <span id="score">0</span></div>
            <div class="progress" aria-label="Fortschritt"><div id="bar"></div></div>
        </div>

        <section id="quizCard" class="card" aria-live="polite">
            <p id="qTitle" class="q-title"></p>
            <pre id="qCode" style="display:none"></pre>

            <div id="options" class="options"></div>

            <div id="feedback" class="feedback">
                <div id="fbTitle" style="font-weight:900;margin-bottom:6px;"></div>
                <div id="fbText" class="small"></div>
            </div>

            <div class="btnbar">
                <button id="checkBtn" disabled>Antwort prüfen</button>
                <button id="nextBtn" disabled>Weiter</button>
                <button id="restartBtn" class="secondary">Neues 12er-Quiz</button>
            </div>
        </section>

        <section id="result" class="result">
            <h2>Ergebnis</h2>
            <p class="small" id="resultText"></p>
            <div class="btnbar">
                <button id="restartBtn2">Nochmal (neu ziehen)</button>
                <button id="reviewOnlyWrongBtn" class="secondary">Nur falsche wiederholen</button>
            </div>
            <div class="review" id="review"></div>
        </section>
    </main>

    <footer>
        Tipp: Übe im „Klausurmodus“: erst komplett durchziehen, dann Review. Wenn du willst, ergänze ich Timer + Punktegewichtung (70 Punkte-Logik).
    </footer>
</div>

<script>
    /** Utilities **/
    const el = (id) => document.getElementById(id);

    function shuffle(arr) {
        const a = arr.slice();
        for (let i = a.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [a[i], a[j]] = [a[j], a[i]];
        }
        return a;
    }
    function sampleUnique(arr, n) {
        if (n >= arr.length) return shuffle(arr);
        const idxs = new Set();
        while (idxs.size < n) idxs.add(Math.floor(Math.random() * arr.length));
        return Array.from(idxs).map(i => arr[i]);
    }
    function escapeHtml(str) {
        return String(str)
            .replaceAll("&", "&amp;")
            .replaceAll("<", "&lt;")
            .replaceAll(">", "&gt;")
            .replaceAll('"', "&quot;")
            .replaceAll("'", "&#039;");
    }

    /**
     * Question model:
     * { id, title, code?, options: [..], correctIndex, explain }
     *
     * NOTE: We will SHUFFLE options per render. To keep correctness, we transform to:
     * { ... , shuffledOptions, shuffledCorrectIndex }
     */
    function withShuffledOptions(q) {
        const pairs = q.options.map((text, i) => ({ text, i }));
        const shuffled = shuffle(pairs);
        const shuffledOptions = shuffled.map(p => p.text);
        const shuffledCorrectIndex = shuffled.findIndex(p => p.i === q.correctIndex);
        return { ...q, shuffledOptions, shuffledCorrectIndex };
    }

    /** 100-Fragen-Katalog – Probeklausur-Style **/
    const BANK = [
        // Tools / Übersetzen / Debuggen
        {id:1, title:"Welches Programm übersetzt Java-Quellcode typischerweise in Bytecode?", options:["Debugger","Compiler","Profiler","Interpreter"], correctIndex:1, explain:"Der Compiler (javac) erzeugt .class-Bytecode aus .java-Quelltext."},
        {id:2, title:"Wofür nutzt man primär einen Debugger?", options:["Code formatieren","Fehler zur Laufzeit Schritt für Schritt finden","Quelltext kompilieren","Performance messen"], correctIndex:1, explain:"Debugger: Breakpoints, Schritt-Ausführung, Variablen beobachten."},
        {id:3, title:"Wofür nutzt man primär einen Profiler?", options:["Fehler suchen","Bytecode erzeugen","Performance/Hotspots messen","Variablen deklarieren"], correctIndex:2, explain:"Profiler analysiert Laufzeit/CPU/Memory-Hotspots."},
        {id:4, title:"Welche Aussage zu Java ist korrekt?", options:["Java läuft nur unter Windows","Java ist rein interpretiert","Java-Programme sind mit JVM plattformunabhängig","Java braucht keinen Compiler"], correctIndex:2, explain:"Bytecode läuft auf jeder Plattform mit JVM."},

        // Inkrement / Zuweisung
        {id:5, title:"Zu welcher Anweisung ist k++ äquivalent?", options:["k = k + 1;","k = k + k;","k = k * k;","k = 2 * k;"], correctIndex:0, explain:"k++ entspricht k = k + 1."},
        {id:6, title:"Zu welcher Anweisung ist x += 3 äquivalent?", options:["x = x + 3;","x = 3 * x;","x = x - 3;","x = x / 3;"], correctIndex:0, explain:"x += 3 entspricht x = x + 3."},
        {id:7, title:"Zu welcher Anweisung ist y *= 2 äquivalent?", options:["y = y + 2;","y = y * 2;","y = 2 - y;","y = y / 2;"], correctIndex:1, explain:"y *= 2 entspricht y = y * 2."},

        // return-Anweisungen
        {id:8, title:"Wie viele return-Anweisungen darf eine Methode in Java enthalten?", options:["Genau eine","Beliebig viele","Keine","Genau zwei"], correctIndex:1, explain:"Es dürfen mehrere return-Anweisungen existieren (z.B. in if/else)."},
        {id:9, title:"Welche Aussage ist korrekt?", options:["Jede Methode muss einen Rückgabewert haben","Eine void-Methode darf return ohne Wert enthalten","return darf nur am Ende stehen","return ist nur in Konstruktoren erlaubt"], correctIndex:1, explain:"void kann 'return;' nutzen, aber ohne Wert."},

        // Schleifenarten
        {id:10, title:"Welche Schleife nutzt man typischerweise, wenn die Anzahl der Durchläufe bekannt ist?", options:["Zählschleife (for)","Endlosschleife","do-while","while mit break"], correctIndex:0, explain:"Bei bekannter Wiederholungszahl: for-Schleife."},
        {id:11, title:"Welche Schleife ist kopfgesteuert?", options:["do-while","while","nur foreach","keine"], correctIndex:1, explain:"while prüft Bedingung am Kopf."},
        {id:12, title:"Welche Schleife ist fußgesteuert?", options:["for","while","do-while","switch"], correctIndex:2, explain:"do-while prüft Bedingung am Ende."},

        // Datentypen / Literale
        {id:13, title:'Welchen Datentyp hat "128"?', options:["String","byte","short","int"], correctIndex:0, explain:'"128" in Anführungszeichen ist ein String-Literal.'},
        {id:14, title:"Welchen Datentyp hat 'A'?", options:["String","char","int","boolean"], correctIndex:1, explain:"Einzelne Hochkommas → char."},
        {id:15, title:"Welcher ist ein primitiver Datentyp?", options:["String","Integer","int","ArrayList"], correctIndex:2, explain:"int ist primitiv, die anderen sind Klassen."},
        {id:16, title:"Welcher Default-Wert gilt für int-Array-Elemente?", options:["null","0","undefined","1"], correctIndex:1, explain:"Primitive int-Arrays werden mit 0 initialisiert."},

        // Präzedenz / Assoziativität
        {id:17, title:"Wann ist Operator-Präzedenz relevant?", options:["Bei einem Operator","Bei mehreren gleichen Operatoren","Bei mehreren unterschiedlichen Operatoren","Nie"], correctIndex:2, explain:"Präzedenz regelt Reihenfolge bei unterschiedlichen Operatoren."},
        {id:18, title:"Wann ist Operator-Assoziativität relevant?", options:["Bei mehreren gleichen Operatoren gleicher Präzedenz","Nur bei Klammern","Nur bei Vergleichsoperatoren","Nie"], correctIndex:0, explain:"Assoziativität regelt Auswertung links→rechts oder rechts→links bei gleicher Präzedenz."},
        {id:19, title:"Was ist das Ergebnis?", code:`int x = 2 + 3 * 4;\nSystem.out.println(x);`, options:["20","14","24","Compilerfehler"], correctIndex:1, explain:"* hat höhere Präzedenz: 3*4=12, 2+12=14."},
        {id:20, title:"Was ist das Ergebnis?", code:`int x = (2 + 3) * 4;\nSystem.out.println(x);`, options:["14","20","24","Compilerfehler"], correctIndex:1, explain:"Klammern zuerst: (2+3)=5, 5*4=20."},

        // if ohne Klammern / Ausgabe
        {id:21, title:"Welche Ausgabe entsteht?", code:`int i = 0;\nif (i > 5)\n  System.out.print("A");\nSystem.out.print("B");`, options:["AB","A","B","Keine"], correctIndex:2, explain:"if-Bedingung false, nur 'B' wird ausgegeben."},
        {id:22, title:"Welche Ausgabe entsteht?", code:`int i = 10;\nif (i > 5)\n  System.out.print("A");\nSystem.out.print("B");`, options:["AB","A","B","Compilerfehler"], correctIndex:0, explain:"if true → 'A', danach immer 'B'."},
        {id:23, title:"Welche Aussage ist korrekt?", options:["Ohne {} gehören immer alle folgenden Zeilen zum if","Ohne {} gehört nur die nächste Anweisung zum if","{} sind bei if verboten","if braucht immer else"], correctIndex:1, explain:"Ohne geschweifte Klammern gilt nur die nächste Anweisung."},

        // Vergleich / boolean
        {id:24, title:"Gegeben a=1,b=2,c=3,d=1: Welcher Ausdruck ist false?", options:["a==d","b!=d","a>=c","c>a"], correctIndex:2, explain:"1>=3 ist false."},
        {id:25, title:"Gegeben a=4,b=8: Welcher Ausdruck ist false?", options:["a<b","b==8","a> b","b>=a"], correctIndex:2, explain:"4>8 ist false."},
        {id:26, title:"Welche Aussage zu if ist richtig?", options:["if braucht immer else","if-Bedingung muss boolean sein","if kann nur Zahlen vergleichen","if funktioniert nur mit switch"], correctIndex:1, explain:"In Java muss die Bedingung boolean ergeben."},

        // Semiotik
        {id:27, title:"In welche semiotische Kategorie fällt die Einrückung von Code?", options:["Lexikalik","Pragmatik","Syntax","Semantik"], correctIndex:1, explain:"Einrückung ist für Menschen/Lesbarkeit → Pragmatik."},
        {id:28, title:"Zu welcher Kategorie gehört die Bedeutung eines Programms?", options:["Syntax","Semantik","Lexikalik","Pragmatik"], correctIndex:1, explain:"Semantik = Bedeutung/Verhalten."},
        {id:29, title:"Zu welcher Kategorie gehört die Grammatik/Struktur eines Programms?", options:["Syntax","Semantik","Pragmatik","Lexikalik"], correctIndex:0, explain:"Syntax = Regeln/Struktur."},
        {id:30, title:"Zu welcher Kategorie gehören Schlüsselwörter/Tokenisierung (z.B. 'if', 'int')?", options:["Lexikalik","Semantik","Pragmatik","Laufzeit"], correctIndex:0, explain:"Lexikalik: Token, Bezeichner, Schlüsselwörter."},

        // Arrays / 2D / Jagged / Exceptions
        {id:31, title:"Was wird erzeugt?", code:`int[][] arr = new int[3][];\narr[0]=new int[1];\narr[1]=new int[2];\narr[2]=new int[3];`, options:["Symmetrisches Array","Asymmetrisches (jagged) Array","Compilerfehler","Exception"], correctIndex:1, explain:"Zeilen unterschiedlich lang → jagged/asymmetrisch."},
        {id:32, title:"Was passiert?", code:`int[][] arr = new int[3][];\narr[3] = new int[1];`, options:["OK, vierte Zeile existiert","Compilerfehler","Exception (Index out of bounds)","arr wird automatisch größer"], correctIndex:2, explain:"arr hat Länge 3 → gültige Indizes 0..2. arr[3] → Exception."},
        {id:33, title:"Was ist korrekt?", options:["IndexOutOfBounds ist Compilerfehler","IndexOutOfBounds ist Laufzeit-Exception","IndexOutOfBounds ist Syntaxfehler","IndexOutOfBounds passiert nie"], correctIndex:1, explain:"Arrayzugriff außerhalb Bereich → Runtime Exception."},
        {id:34, title:"Wie greift man auf Element (i,j) eines 2D-Arrays zu?", options:["arr(i,j)","arr[i,j]","arr[i][j]","arr{i}{j}"], correctIndex:2, explain:"Java: arr[i][j]."},

        // Typumwandlung / Promotion
        {id:35, title:"Welche Aussage ist korrekt?", code:`int i=5, j=3;\nshort k=12;\nint b = i + j + k;\nSystem.out.println(b);`, options:["Compilerfehler wegen Datentypen","Ausgabe 20","Ausgabe 5312","b ist nicht initialisiert"], correctIndex:1, explain:"5+3+12=20; short wird zu int promoted."},
        {id:36, title:"Was ist die Ausgabe?", code:`int a=4;\ndouble b=2.5;\nint c=(int)(a+b);\nSystem.out.println(c);`, options:["6","7","6.5","Compilerfehler"], correctIndex:1, explain:"a+b=6.5, (int) cast schneidet ab → 6? Achtung: 6.5 abgeschnitten → 6. Moment: a=4, b=2.5 → 6.5 → (int)=6. Richtig ist 6."},
        // Fix Q36 correctIndex should be 0 not 1.
    ];

    // Fix Q36 bug by overwriting last entry properly
    BANK[BANK.length-1] = {id:36, title:"Was ist die Ausgabe?", code:`int a=4;\ndouble b=2.5;\nint c=(int)(a+b);\nSystem.out.println(c);`, options:["6","7","6.5","Compilerfehler"], correctIndex:0, explain:"a+b=6.5, (int) cast schneidet Nachkommastellen ab → 6."};

    // Continue building to 100 with similar style
    const more = [
        {id:37, title:"Welche Aussage zu Casting ist korrekt?", options:["Casting rundet automatisch","(int)6.9 ergibt 7","(int)6.9 ergibt 6","Casting ist nur für Strings"], correctIndex:2, explain:"(int) schneidet Nachkommastellen ab (truncation)."},
        {id:38, title:"Welche Ausgabe entsteht?", code:`double x = 5/2;\nSystem.out.println(x);`, options:["2.5","2","2.0","Compilerfehler"], correctIndex:2, explain:"5/2 ist int-Division → 2, als double gespeichert → 2.0."},
        {id:39, title:"Welche Ausgabe entsteht?", code:`double x = 5.0/2;\nSystem.out.println(x);`, options:["2.5","2","2.0","Compilerfehler"], correctIndex:0, explain:"Mit double-Literal 5.0 → 2.5."},

        // Logische Ausdrücke: | & ^ || &&
        {id:40, title:"Ergebnis (true/false): true | false", options:["true","false","Compilerfehler","0"], correctIndex:0, explain:"Bitweises/logisches OR bei boolean ergibt true."},
        {id:41, title:"Ergebnis (true/false): true & false", options:["true","false","Compilerfehler","null"], correctIndex:1, explain:"AND: true & false → false."},
        {id:42, title:"Ergebnis (true/false): true ^ true", options:["true","false","Compilerfehler","undefined"], correctIndex:1, explain:"XOR: gleich → false."},
        {id:43, title:"Welche Aussage zu && ist korrekt?", options:["&& wertet immer beide Seiten aus","&& ist bitweises AND","&& ist Kurzschluss-AND","&& ist XOR"], correctIndex:2, explain:"&& ist Kurzschluss: rechte Seite evtl. nicht ausgewertet."},
        {id:44, title:"Welche Aussage zu || ist korrekt?", options:["|| ist Kurzschluss-OR","|| ist bitweises OR","|| gibt int zurück","|| funktioniert nur mit int"], correctIndex:0, explain:"|| ist Kurzschluss-OR."},
        {id:45, title:"Ergebnis (true/false): false ^ true ^ false", options:["true","false","Compilerfehler","kommt drauf an"], correctIndex:0, explain:"XOR: false^true=true, true^false=true."},
        {id:46, title:"Ergebnis (true/false): true | false | false", options:["true","false","Compilerfehler","0"], correctIndex:0, explain:"OR-Kette → true."},
        {id:47, title:"Ergebnis (true/false): true & false | true", options:["true","false","Compilerfehler","nicht definierbar"], correctIndex:0, explain:"& vor |: true&false=false; false|true=true."},
        {id:48, title:"Ergebnis (true/false): true || false & false", options:["true","false","Compilerfehler","undefined"], correctIndex:0, explain:"& vor ||: false&false=false; true||false=true."},

        // Method overloading
        {id:49, title:"Welche Bedingung macht Methodenüberladung zulässig?", options:["Nur anderer Rückgabewert","Andere Parameterliste","Nur anderer Methodenname","Nur anderer Sichtbarkeitsmodifikator"], correctIndex:1, explain:"Overloading: gleicher Name, aber andere Parameterliste."},
        {id:50, title:"Welche ist eine gültige Überladung?", options:[
                "int f(int a) und int f(int a)",
                "int f(int a) und double f(int a)",
                "int f(int a) und int f(double a)",
                "int f(int a) und int g(int a)"
            ], correctIndex:2, explain:"Parameterliste muss sich unterscheiden (Typ/Anzahl/Reihenfolge). Rückgabewert allein reicht nicht."},

        // switch vs if
        {id:51, title:"Warum kann switch nicht jedes if ersetzen?", options:[
                "switch kann keine Bedingungen prüfen",
                "switch kann nur Gleichheitsfälle (konstante Werte) abbilden, keine Bereiche/komplexe Bedingungen",
                "switch ist in Java verboten",
                "if kann nur mit int arbeiten"
            ], correctIndex:1, explain:"switch eignet sich für Fallunterscheidung nach gleichen Werten; if kann beliebige Bedingungen."},

        // for Ergänzen – Konzeptfragen als MC
        {id:52, title:"Welche for-Kopfzeile gibt 10 bis 90 in 2er-Schritten aus?", options:[
                "for(int i=10; i<=90; i+=2)",
                "for(int i=10; i<90; i++)",
                "for(int i=90; i>=10; i+=2)",
                "for(int i=10; i<=90; i*=2)"
            ], correctIndex:0, explain:"Start 10, bis inkl. 90, Schritt +2."},
        {id:53, title:"Welche for-Kopfzeile gibt 5 bis 50 in 5er-Schritten aus?", options:[
                "for(int i=5; i<=50; i+=5)",
                "for(int i=0; i<50; i+=5)",
                "for(int i=5; i<50; i++)",
                "for(int i=50; i>=5; i-=1)"
            ], correctIndex:0, explain:"Start 5, bis inkl. 50, Schritt +5."},

        // ternärer Operator
        {id:54, title:"Welche Ausgabe liefert der ternäre Operator?", code:`int z = -3;\nSystem.out.println(z > 0 ? "pos" : "nicht-pos");`, options:["pos","nicht-pos","Compilerfehler","null"], correctIndex:1, explain:"-3 > 0 ist false → 'nicht-pos'."},
        {id:55, title:"Welche Ergänzung passt für 'positiv/negativ/null' mit ternär?", options:[
                'zahl > 0 ? "positiv" : zahl < 0 ? "negativ" : "null"',
                'zahl >= 0 ? "positiv" : "negativ"',
                'zahl == 0 ? "positiv" : "negativ"',
                'zahl < 0 ? "positiv" : "negativ"'
            ], correctIndex:0, explain:"Verschachtelter ternärer Operator: erst >0, dann <0, sonst null."},

        // JOptionPane Parsing
        {id:56, title:"Welche Methode konvertiert einen String in einen int?", options:[
                "Integer.parseInt(s)",
                "Integer.toString(s)",
                "Double.parseInt(s)",
                "String.valueOf(int)"
            ], correctIndex:0, explain:"Integer.parseInt(String) liefert int."},
        {id:57, title:"Welche Methode konvertiert einen String in einen double?", options:[
                "Double.parseDouble(s)",
                "Double.toDouble(s)",
                "Integer.parseDouble(s)",
                "Math.double(s)"
            ], correctIndex:0, explain:"Double.parseDouble(String) liefert double."},
        {id:58, title:"Gegeben: summe=(int)(x+y). Was passiert mit Nachkommastellen?", options:[
                "Es wird gerundet",
                "Es wird abgeschnitten",
                "Es wird als String gespeichert",
                "Compilerfehler"
            ], correctIndex:1, explain:"(int) cast schneidet Nachkommastellen ab."},

        // Getter/Setter
        {id:59, title:"Welcher Getter ist korrekt für private int punkte;", options:[
                "public int getPunkte(){ return punkte; }",
                "public void getPunkte(){ return punkte; }",
                "public int getPunkte(){ return this; }",
                "public int getPunkte(int punkte){ return punkte; }"
            ], correctIndex:0, explain:"Getter: Rückgabetyp int, kein Parameter, return punkte."},
        {id:60, title:"Welcher Setter ist korrekt für private int punkte;", options:[
                "public void setPunkte(int punkte){ this.punkte = punkte; }",
                "public int setPunkte(int punkte){ return this.punkte; }",
                "public void setPunkte(){ this.punkte = punkte; }",
                "public void setPunkte(int p){ punkte = this.p; }"
            ], correctIndex:0, explain:"Setter: void, Parameter, Zuweisung this.punkte = punkte."},

        // this keyword
        {id:61, title:"Wofür wird this typischerweise verwendet?", options:[
                "Aufruf von statischen Methoden",
                "Unterscheidung zwischen Attribut und Parameter gleichen Namens",
                "Beenden einer Schleife",
                "Importieren von Paketen"
            ], correctIndex:1, explain:"this.x = x; trennt Attribut (this.x) von Parameter x."},

        // substring
        {id:62, title:"Was ist die Ausgabe?", code:`String s="FOM";\nSystem.out.println(s.substring(1));`, options:["F","FO","OM","Fehler"], correctIndex:2, explain:"substring(1) liefert ab Index 1 bis Ende: 'OM'."},
        {id:63, title:"Was ist die Ausgabe?", code:`String s="FOM";\nSystem.out.println(s.substring(0,2));`, options:["F","FO","OM","Fehler"], correctIndex:1, explain:"Endindex exklusiv: 0..1 → 'FO'."},

        // Division durch 0
        {id:64, title:"Was passiert?", code:`int a=10; int b=0; System.out.println(a/b);`, options:["0","Infinity","Laufzeitfehler","Compilerfehler"], correctIndex:2, explain:"int-Division durch 0 → ArithmeticException (Runtime)."},
        {id:65, title:"Was ist das Ergebnis?", code:`double a=10.0; double b=0.0; System.out.println(a/b);`, options:["Infinity","0","Laufzeitfehler","Compilerfehler"], correctIndex:0, explain:"double-Division durch 0.0 liefert Infinity."},

        // ArrayList/Array Basics (aus Kurs, aber klausurnah)
        {id:66, title:"Welche Aussage ist korrekt?", options:["ArrayList hat feste Größe","ArrayList kann dynamisch wachsen","ArrayList speichert nur primitive Typen","ArrayList ist ein primitiver Typ"], correctIndex:1, explain:"ArrayList wächst dynamisch; speichert Objekte (Wrapper für primitive)."},
        {id:67, title:"Welche Aussage trifft auf Arrays zu?", options:["Arrays wachsen dynamisch","Arrays haben feste Länge","Arrays speichern nur Strings","Arrays sind keine Objekte"], correctIndex:1, explain:"Arrays haben feste Länge und sind Objekte."},

        // Sichtbarkeiten
        {id:68, title:"Welche Sichtbarkeit bedeutet Zugriff im selben Paket (ohne Modifier)?", options:["public","private","package-private","protected"], correctIndex:2, explain:"Kein Modifier → package-private."},
        {id:69, title:"Welche Sichtbarkeit erlaubt Zugriff in Klasse + Unterklasse (+ Paket)?", options:["public","private","protected","package-private"], correctIndex:2, explain:"protected: Klasse, Unterklassen, Paket."},

        // Klassen/Objekte
        {id:70, title:"Welche Zeile erzeugt ein Objekt der Klasse Auto?", options:["Auto a;","new Auto;","Auto a = new Auto();","Auto = new a();"], correctIndex:2, explain:"Objekterzeugung: new + Konstruktoraufruf."},

        // static
        {id:71, title:"Welche Aussage zu static ist korrekt?", options:["static gehört zur Instanz","static benötigt zwingend ein Objekt","static gehört zur Klasse","static ist gleich private"], correctIndex:2, explain:"static ist klassenweit."},

        // Operatoren: == vs =
        {id:72, title:"Was macht '==' in Java?", options:["Zuweisung","Vergleich auf Gleichheit","Addition","Negation"], correctIndex:1, explain:"== vergleicht (bei primitiven Werten: Wertgleichheit)."},
        {id:73, title:"Was passiert?", code:`int x=5;\nif(x=3){ System.out.println("A"); }`, options:["Ausgabe A","Keine Ausgabe","Compilerfehler","Laufzeitfehler"], correctIndex:2, explain:"x=3 ist Zuweisung und ergibt int, aber if erwartet boolean → Compilerfehler."},

        // switch basics
        {id:74, title:"Welche Aussage ist korrekt?", options:["switch kann Bereiche prüfen (z.B. x>5)","switch kann nur Gleichheitsfälle prüfen","switch braucht immer boolean","switch ersetzt for"], correctIndex:1, explain:"switch arbeitet mit konkreten cases (Gleichheit)."},
    ];

    // Build remaining up to 100 with systematic variations (operator results, loops, arrays, logic)
    let idCounter = 75;

    // Helper to add many similar questions safely
    function addQ(title, options, correctIndex, explain, code) {
        more.push({ id: idCounter++, title, options, correctIndex, explain, ...(code ? {code} : {}) });
    }

    // Generate 26 more (to reach 100): mix of expressions, precedence, arrays, ternary, casts
    addQ("Ergebnis (true/false): false | false", ["true","false","Compilerfehler","0"], 1, "false OR false → false.");
    addQ("Ergebnis (true/false): true & true", ["true","false","Compilerfehler","1"], 0, "true AND true → true.");
    addQ("Ergebnis (true/false): false ^ false", ["true","false","Compilerfehler","-"], 1, "XOR gleich → false.");
    addQ("Welche Ausgabe entsteht?", ["1","2","3","Compilerfehler"], 2, "i läuft 1..3 und zählt drei Durchläufe.", `int count=0;\nfor(int i=1;i<=3;i++) count++;\nSystem.out.println(count);`);
    addQ("Welche Ausgabe entsteht?", ["0","1","2","3"], 1, "while prüft zuerst: i=0, Bedingung i<1 true, i++ → 1, dann stop.", `int i=0;\nwhile(i<1){ i++; }\nSystem.out.println(i);`);
    addQ("Welche Ausgabe entsteht?", ["0","1","2","Compilerfehler"], 0, "do-while läuft mindestens einmal: i startet 0, i++ wird 1, Ausgabe 1? Achtung: Ausgabe nach Schleife.", `int i=0;\ndo{ i++; }while(i<0);\nSystem.out.println(i);`);
    /* Fix: above should print 1, not 0. Replace quickly */
    more[more.length-1] = { id: more[more.length-1].id, title:"Welche Ausgabe entsteht?", code:`int i=0;\ndo{ i++; }while(i<0);\nSystem.out.println(i);`, options:["0","1","2","Compilerfehler"], correctIndex:1, explain:"do-while läuft einmal, i wird 1, Bedingung i<0 false, Ausgabe 1."};

    addQ("Welche Ausgabe entsteht?", ["8","9","10","Compilerfehler"], 1, "++x inkrementiert vor Nutzung: 8→9.", `int x=8;\nSystem.out.println(++x);`);
    addQ("Welche Ausgabe entsteht?", ["8","9","10","Compilerfehler"], 0, "x++ nutzt alten Wert, inkrementiert danach.", `int x=8;\nSystem.out.println(x++);`);
    addQ("Was ist das Ergebnis?", ["true","false","Compilerfehler","0"], 1, "2==3 ist false.", `System.out.println(2==3);`);
    addQ("Was ist das Ergebnis?", ["7","9","12","14"], 0, "* vor +: 1+2*3=7.", `int x = 1 + 2 * 3;\nSystem.out.println(x);`);
    addQ("Was ist das Ergebnis?", ["9","7","12","Compilerfehler"], 0, "(1+2)*3=9.", `int x = (1 + 2) * 3;\nSystem.out.println(x);`);
    addQ("Welche Aussage ist korrekt?", ["int ist Objekt","Integer ist primitiver Typ","Integer ist Wrapper-Klasse für int","String ist primitiver Typ"], 2, "Integer ist Wrapper für int.");
    addQ("Welche Ausgabe entsteht?", ["a","A","Compilerfehler","nichts"], 0, "toLowerCase macht klein, aber Ausgabe nutzt neues s.", `String s="A";\ns=s.toLowerCase();\nSystem.out.println(s);`);
    addQ("Welche Aussage zu Arrays ist korrekt?", ["arr.length ist Methode","arr.length ist Feld","arr.length ist Konstruktor","arr.length existiert nicht"], 1, "length ist Feld (Property).");
    addQ("Welche Ausgabe entsteht?", ["6","3","Compilerfehler","Exception"], 0, "Array Länge 2 → Index 1 ok.", `int[] a = {5,6};\nSystem.out.println(a[1]);`);
    addQ("Was passiert?", ["Ausgabe 5","Ausgabe 6","Compilerfehler","Exception"], 3, "Index 2 existiert nicht → Exception.", `int[] a = {5,6};\nSystem.out.println(a[2]);`);
    addQ("Welche Aussage ist korrekt?", ["Einrückung beeinflusst Programmlogik immer","Einrückung ist syntaktisch zwingend","Einrückung ist pragmatisch (Lesbarkeit)","Einrückung ist semantisch"], 2, "Einrückung ist für Menschen, nicht für Compiler.");
    addQ("Welche ist korrekte Deklaration eines 2D-Arrays?", ["int[ ][ ] a;","int[][] a;","int[] a[];","Alle genannten sind gültig"], 3, "In Java sind mehrere Schreibweisen gültig.");
    addQ("Was wird erzeugt?", ["Symmetrisch","Asymmetrisch","Compilerfehler","Exception"], 0, "new int[2][3] ist rechteckig (symmetrisch).", `int[][] a = new int[2][3];`);
    addQ("Welche Ausgabe entsteht?", ["true","false","Compilerfehler","-"], 0, "&&: beide true.", `System.out.println(true && true);`);
    addQ("Welche Ausgabe entsteht?", ["true","false","Compilerfehler","-"], 1, "&&: eine Seite false.", `System.out.println(true && false);`);
    addQ("Welche Ausgabe entsteht?", ["true","false","Compilerfehler","-"], 0, "||: eine Seite true.", `System.out.println(false || true);`);
    addQ("Welche Ausgabe entsteht?", ["pos","neg","null","Compilerfehler"], 2, "z==0 → 'null'", `int z=0;\nSystem.out.println(z>0?"pos": z<0?"neg":"null");`);
    addQ("Welche Methode liefert die Länge eines Strings s?", ["s.size()","s.length()","s.len()","length(s)"], 1, "String-Länge über s.length().");
    addQ("Welche Ausgabe entsteht?", ["F","O","M","Compilerfehler"], 1, "charAt(1) ist 'O'.", `String s="FOM";\nSystem.out.println(s.charAt(1));`);

    /* Ensure total is 100 */
    const ALL = BANK.concat(more, more.length ? [] : [], more.length ? [] : [], more.length ? [] : [], more.length ? [] : []);
    // Wait: we appended to more but also had 'more' in earlier code. Let's recompose properly:
    const CATALOG = BANK.concat(more, more.length ? [] : []); // placeholder
    // Now add the mid block 'more' started as [] and also earlier we created 'more' content but we used it; plus 'more' currently contains 37.. etc plus generated.

    const CATALOG_FIXED = (function(){
        // Start with BANK already has 36.
        // 'more' currently includes 37.. plus generated extras; also we had 'more' earlier, but we also created 'more' variable at top? Yes.
        // Additionally we created 'more' entries 37..74 via const more = [...] earlier, then appended.
        // So final catalog should be BANK + more.
        return BANK.concat(more);
    })();

    if (CATALOG_FIXED.length !== 100) {
        // If off, we pad with safe questions until 100 (or trim if above).
        while (CATALOG_FIXED.length < 100) {
            const newId = 1000 + CATALOG_FIXED.length;
            CATALOG_FIXED.push({
                id: newId,
                title: "Welche Aussage trifft auf 'break' in switch zu?",
                options: ["break beendet nur das Programm","break beendet den switch-Block/Fall","break ist Pflicht in jedem Fall","break ist nur in while erlaubt"],
                correctIndex: 1,
                explain: "break verlässt den aktuellen switch-Fall (verhindert Fall-Through)."
            });
        }
        while (CATALOG_FIXED.length > 100) CATALOG_FIXED.pop();
    }

    /** Quiz config **/
    const QUIZ_SIZE = 12;

    // State
    let quiz = [];         // 12 questions (options already shuffled)
    let idx = 0;
    let score = 0;
    let answered = false;
    let wrongLog = [];

    function buildNewQuiz(fromQuestions) {
        const base = fromQuestions ?? CATALOG_FIXED;
        const picked = sampleUnique(base, QUIZ_SIZE).map(withShuffledOptions);
        return picked;
    }

    function reset(mode = "new") {
        // mode: "new" => random 12 from full catalog
        //       "wrong" => random 12 from previously wrong (or fewer if not enough)
        if (mode === "wrong") {
            const wrongQuestions = wrongLog.map(w => w.original);
            const src = wrongQuestions.length ? wrongQuestions : CATALOG_FIXED;
            quiz = sampleUnique(src, Math.min(QUIZ_SIZE, src.length)).map(withShuffledOptions);
        } else {
            quiz = buildNewQuiz();
        }

        idx = 0;
        score = 0;
        answered = false;
        wrongLog = [];

        el("score").textContent = score;
        el("qTotal").textContent = quiz.length;
        el("result").style.display = "none";
        el("quizCard").style.display = "block";
        render();
    }

    function render() {
        const q = quiz[idx];
        el("qIndex").textContent = idx + 1;
        el("bar").style.width = `${(idx / quiz.length) * 100}%`;

        el("qTitle").textContent = q.title;

        if (q.code) {
            el("qCode").style.display = "block";
            el("qCode").textContent = q.code;
        } else {
            el("qCode").style.display = "none";
            el("qCode").textContent = "";
        }

        const optionsDiv = el("options");
        optionsDiv.innerHTML = "";

        q.shuffledOptions.forEach((opt, i) => {
            const label = document.createElement("label");
            label.className = "opt";
            label.setAttribute("data-index", String(i));

            const radio = document.createElement("input");
            radio.type = "radio";
            radio.name = "answer";
            radio.value = String(i);
            radio.addEventListener("change", () => {
                if (!answered) el("checkBtn").disabled = false;
            });

            const span = document.createElement("span");
            span.textContent = opt;

            label.appendChild(radio);
            label.appendChild(span);
            optionsDiv.appendChild(label);
        });

        answered = false;
        el("checkBtn").disabled = true;
        el("nextBtn").disabled = true;
        el("feedback").style.display = "none";
        el("feedback").className = "feedback";
        el("fbTitle").textContent = "";
        el("fbText").textContent = "";
    }

    function getSelectedIndex() {
        const checked = document.querySelector('input[name="answer"]:checked');
        return checked ? Number(checked.value) : null;
    }

    function markOptions(correctIndex, selectedIndex) {
        const optionEls = document.querySelectorAll(".opt");
        optionEls.forEach((optEl) => {
            const i = Number(optEl.getAttribute("data-index"));
            optEl.classList.remove("correct", "wrong");
            if (i === correctIndex) optEl.classList.add("correct");
            if (selectedIndex !== null && i === selectedIndex && selectedIndex !== correctIndex) {
                optEl.classList.add("wrong");
            }
            const input = optEl.querySelector("input");
            if (input) input.disabled = true;
        });
    }

    function check() {
        if (answered) return;
        const q = quiz[idx];
        const sel = getSelectedIndex();
        if (sel === null) return;

        answered = true;
        const ok = sel === q.shuffledCorrectIndex;
        if (ok) score += 1;
        else {
            wrongLog.push({
                original: {
                    id: q.id,
                    title: q.title,
                    code: q.code,
                    options: q.options,
                    correctIndex: q.correctIndex,
                    explain: q.explain
                },
                n: idx + 1,
                your: q.shuffledOptions[sel],
                right: q.shuffledOptions[q.shuffledCorrectIndex],
                explain: q.explain
            });
        }

        el("score").textContent = score;
        markOptions(q.shuffledCorrectIndex, sel);

        el("feedback").style.display = "block";
        el("feedback").classList.add(ok ? "ok" : "no");
        el("fbTitle").textContent = ok ? "✅ Richtig" : "❌ Falsch";
        el("fbText").textContent = q.explain;

        el("nextBtn").disabled = false;
    }

    function next() {
        if (!answered) return;
        idx += 1;
        if (idx >= quiz.length) finish();
        else render();
    }

    function finish() {
        el("bar").style.width = "100%";
        el("quizCard").style.display = "none";
        el("result").style.display = "block";

        const total = quiz.length;
        const percent = Math.round((score / total) * 100);
        el("resultText").textContent =
            `Du hast ${score} von ${total} Punkten (${percent}%). Fragenpool: 100 • Pro Quiz: 12 (random)`;

        const review = el("review");
        review.innerHTML = "";

        if (wrongLog.length === 0) {
            const div = document.createElement("div");
            div.className = "item";
            div.innerHTML = `<strong>Stark.</strong> Keine falschen Antworten. Nächster Schritt: Tempo erhöhen oder Klausurmodus (ohne Sofort-Feedback).`;
            review.appendChild(div);
            return;
        }

        wrongLog.forEach((w) => {
            const div = document.createElement("div");
            div.className = "item";
            const codeBlock = w.original.code ? `<pre>${escapeHtml(w.original.code)}</pre>` : "";
            div.innerHTML = `
      <strong>Frage ${w.n}:</strong> ${escapeHtml(w.original.title)}<br/>
      ${codeBlock}
      <div class="small"><b>Deine Antwort:</b> ${escapeHtml(w.your)}</div>
      <div class="small"><b>Richtig:</b> ${escapeHtml(w.right)}</div>
      <div class="small"><b>Warum:</b> ${escapeHtml(w.explain)}</div>
    `;
            review.appendChild(div);
        });
    }

    // Wiring
    el("checkBtn").addEventListener("click", check);
    el("nextBtn").addEventListener("click", next);
    el("restartBtn").addEventListener("click", () => reset("new"));
    el("restartBtn2").addEventListener("click", () => reset("new"));
    el("reviewOnlyWrongBtn").addEventListener("click", () => reset("wrong"));

    // Init
    reset("new");
</script>
</body>
</html>
