<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Java MC-Quiz ‚Äì 12 aus 500 (Probeklausur-Stil, validiert)</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;margin:0;padding:24px;background:#f6f7fb;color:#0f172a}
    .app{max-width:980px;margin:0 auto;background:#fff;border-radius:16px;box-shadow:0 12px 30px rgba(2,8,23,.08);overflow:hidden}
    header{padding:18px 20px;background:linear-gradient(135deg,#0ea5e9,#6366f1);color:#fff;display:flex;align-items:center;justify-content:space-between;gap:12px}
    header h1{font-size:16px;margin:0;font-weight:900}
    header .meta{font-size:13px;opacity:.95}
    main{padding:20px}
    .row{display:flex;flex-wrap:wrap;gap:10px;align-items:center;justify-content:space-between;margin-bottom:16px}
    .pill{display:inline-flex;align-items:center;gap:8px;background:#eef2ff;color:#3730a3;border:1px solid #e0e7ff;padding:8px 12px;border-radius:999px;font-size:13px;font-weight:800}
    .progress{flex:1;min-width:220px;height:10px;background:#e5e7eb;border-radius:999px;overflow:hidden}
    .progress>div{height:100%;width:0%;background:#22c55e;transition:width .25s ease}
    .card{border:1px solid #e5e7eb;border-radius:14px;padding:16px;background:#fff}
    .q-title{margin:0 0 10px 0;font-size:16px;font-weight:900}
    pre{background:#0b1220;color:#e5e7eb;padding:12px 14px;border-radius:12px;overflow:auto;margin:10px 0 14px 0;font-size:13px;line-height:1.35}
    .options{display:grid;gap:10px;margin-top:8px}
    .opt{border:1px solid #e5e7eb;border-radius:12px;padding:10px 12px;display:flex;gap:10px;align-items:flex-start;cursor:pointer;user-select:none;transition:border-color .15s ease,background .15s ease}
    .opt:hover{border-color:#cbd5e1;background:#f8fafc}
    .opt input{margin-top:2px}
    .opt.correct{border-color:#16a34a;background:#f0fdf4}
    .opt.wrong{border-color:#dc2626;background:#fef2f2}
    .feedback{margin-top:14px;padding:12px 12px;border-radius:12px;border:1px solid #e5e7eb;background:#f8fafc;display:none}
    .feedback.ok{border-color:#16a34a;background:#f0fdf4}
    .feedback.no{border-color:#dc2626;background:#fef2f2}
    .btnbar{display:flex;gap:10px;margin-top:14px;flex-wrap:wrap}
    button{border:0;border-radius:12px;padding:10px 14px;font-weight:900;cursor:pointer;background:#111827;color:#fff}
    button.secondary{background:#e5e7eb;color:#111827}
    button:disabled{opacity:.55;cursor:not-allowed}
    .result{display:none;border:1px solid #e5e7eb;border-radius:14px;padding:16px;background:#fff}
    .result h2{margin:0 0 8px 0;font-size:18px}
    .review{margin-top:12px;display:grid;gap:10px}
    .review .item{border:1px solid #e5e7eb;border-radius:12px;padding:12px;background:#f8fafc}
    .small{font-size:13px;color:#334155}
    .danger{border:1px solid #fecaca;background:#fef2f2;color:#7f1d1d;padding:10px 12px;border-radius:12px;margin-bottom:14px;display:none}
  </style>
</head>
<body>
<div class="app">
  <header>
    <div>
      <h1>Java MC-Quiz ‚Äì 12 aus 500 (Probeklausur-Stil)</h1>
      <div class="meta">Random 12 Fragen pro Durchlauf ‚Ä¢ Antworten berechnet ‚Ä¢ Self-Check beim Start</div>
    </div>
    <div class="meta"><b>Pool:</b> <span id="poolSize">0</span> ‚Ä¢ <b>Quiz:</b> 12</div>
  </header>

  <main>
    <div id="fatal" class="danger"></div>

    <div class="row">
      <div class="pill">Frage: <span id="qIndex">1</span>/<span id="qTotal">12</span></div>
      <div class="pill">Punkte: <span id="score">0</span></div>
      <div class="progress" aria-label="Fortschritt"><div id="bar"></div></div>
    </div>

    <section id="quizCard" class="card" aria-live="polite">
      <p id="qTitle" class="q-title"></p>
      <pre id="qCode" style="display:none"></pre>

      <div id="options" class="options"></div>

      <div id="feedback" class="feedback">
        <div id="fbTitle" style="font-weight:900;margin-bottom:6px;"></div>
        <div id="fbText" class="small"></div>
      </div>

      <div class="btnbar">
        <button id="checkBtn" disabled>Antwort pr√ºfen</button>
        <button id="nextBtn" disabled>Weiter</button>
        <button id="restartBtn" class="secondary">Neues 12er-Quiz</button>
      </div>
    </section>

    <section id="result" class="result">
      <h2>Ergebnis</h2>
      <p class="small" id="resultText"></p>
      <div class="btnbar">
        <button id="restartBtn2">Nochmal (neu ziehen)</button>
        <button id="reviewOnlyWrongBtn" class="secondary">Nur falsche wiederholen</button>
      </div>
      <div class="review" id="review"></div>
    </section>
  </main>
</div>

<script>
/** ---------- Utils ---------- **/
const el = (id) => document.getElementById(id);

function shuffle(arr) {
  const a = arr.slice();
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

function sampleUnique(arr, n) {
  if (n >= arr.length) return shuffle(arr);
  const idxs = new Set();
  while (idxs.size < n) idxs.add(Math.floor(Math.random() * arr.length));
  return Array.from(idxs).map(i => arr[i]);
}

function escapeHtml(str) {
  return String(str)
    .replaceAll("&", "&amp;")
    .replaceAll("<", "&lt;")
    .replaceAll(">", "&gt;")
    .replaceAll('"', "&quot;")
    .replaceAll("'", "&#039;");
}

function uniq(arr) {
  return Array.from(new Set(arr));
}

function assert(condition, msg) {
  if (!condition) throw new Error(msg);
}

/** ---------- Question Model ---------- **/
/**
 * We store "canonical" questions with correctIndex.
 * On each render we shuffle options and compute shuffledCorrectIndex.
 */
function withShuffledOptions(q) {
  const pairs = q.options.map((text, i) => ({ text, i }));
  const shuffledPairs = shuffle(pairs);
  const shuffledOptions = shuffledPairs.map(p => p.text);
  const shuffledCorrectIndex = shuffledPairs.findIndex(p => p.i === q.correctIndex);
  return { ...q, shuffledOptions, shuffledCorrectIndex };
}

/** ---------- Generators (safe, computed) ---------- **/
let nextId = 1;
function mkQ({title, code=null, options, correctIndex, explain}) {
  return { id: nextId++, title, code, options, correctIndex, explain };
}

function mkSingleCorrectOptions(correctText, wrongTexts) {
  const options = uniq([correctText, ...wrongTexts]).slice(0,4);
  // If uniqueness reduced options <4, pad safely
  while (options.length < 4) options.push(`(Ablenkung ${options.length})`);
  const correctIndex = options.indexOf(correctText);
  return { options, correctIndex };
}

/** Topic: Tools */
function genTools(n) {
  const qs = [];
  const base = [
    {q:"Welches Programm √ºbersetzt Java-Quellcode in Bytecode?", a:"Compiler", wrong:["Debugger","Profiler","Interpreter"],
      ex:"Compiler (javac) erzeugt .class-Bytecode aus .java."},
    {q:"Welches Programm dient der Fehlersuche zur Laufzeit (Breakpoints, Step-Through)?", a:"Debugger", wrong:["Compiler","Profiler","Interpreter"],
      ex:"Debugger: Schritt-f√ºr-Schritt und Variablen beobachten."},
    {q:"Welches Programm misst prim√§r Performance/Hotspots (CPU/Memory)?", a:"Profiler", wrong:["Debugger","Compiler","Interpreter"],
      ex:"Profiler analysiert Performance/Hotspots."},
    {q:"Welche Aussage zu Java ist korrekt?", a:"Java-Programme sind mit JVM plattformunabh√§ngig", wrong:["Java l√§uft nur unter Windows","Java ist rein interpretiert","Java ben√∂tigt keinen Compiler"],
      ex:"Bytecode l√§uft auf jeder Plattform mit JVM."}
  ];
  for (let i=0;i<n;i++){
    const b = base[i % base.length];
    const {options, correctIndex} = mkSingleCorrectOptions(b.a, b.wrong);
    qs.push(mkQ({title:b.q, options, correctIndex, explain:b.ex}));
  }
  return qs;
}

/** Topic: Operators/precedence/arithmetic results */
function genArithmetic(n) {
  const qs = [];
  for (let i=0;i<n;i++){
    // generate expression of form a + b * c OR (a+b)*c
    const a = 1 + (i*3)%9;          // 1..9
    const b = 2 + (i*5)%8;          // 2..9
    const c = 2 + (i*7)%7;          // 2..8
    const withParens = (i % 2 === 1);
    const expr = withParens ? `(${a} + ${b}) * ${c}` : `${a} + ${b} * ${c}`;
    const correct = withParens ? (a+b)*c : (a + b*c);

    const wrong1 = withParens ? (a + b*c) : ((a+b)*c); // swapped precedence
    const wrong2 = correct + (i%3 ? 1 : -1);
    const wrong3 = correct + (i%4 ? 2 : -2);

    const title = "Was ist die Ausgabe?";
    const code = `int x = ${expr};\nSystem.out.println(x);`;
    const {options, correctIndex} = mkSingleCorrectOptions(String(correct), [String(wrong1), String(wrong2), String(wrong3)]);
    qs.push(mkQ({title, code, options, correctIndex, explain:`Pr√§zedenz: * vor +. Klammern steuern die Reihenfolge. Ergebnis: ${correct}.`}));
  }
  return qs;
}

/** Topic: Increment/compound assignment */
function genIncrement(n) {
  const qs = [];
  for (let i=0;i<n;i++){
    const x = 1 + (i%9);
    const kind = i % 3;
    if (kind === 0) {
      const correct = x+1;
      const code = `int x = ${x};\nSystem.out.println(++x);`;
      const {options, correctIndex} = mkSingleCorrectOptions(String(correct), [String(x), String(x+2), "Compilerfehler"]);
      qs.push(mkQ({title:"Welche Ausgabe entsteht?", code, options, correctIndex, explain:"++x erh√∂ht zuerst, dann wird der neue Wert ausgegeben."}));
    } else if (kind === 1) {
      const correct = x;
      const code = `int x = ${x};\nSystem.out.println(x++);`;
      const {options, correctIndex} = mkSingleCorrectOptions(String(correct), [String(x+1), String(x-1), "Compilerfehler"]);
      qs.push(mkQ({title:"Welche Ausgabe entsteht?", code, options, correctIndex, explain:"x++ gibt zuerst den alten Wert aus, erh√∂ht danach."}));
    } else {
      const add = 2 + (i%7);
      const correct = x + add;
      const code = `int x = ${x};\nx += ${add};\nSystem.out.println(x);`;
      const {options, correctIndex} = mkSingleCorrectOptions(String(correct), [String(x), String(x*add), "Compilerfehler"]);
      qs.push(mkQ({title:"Welche Ausgabe entsteht?", code, options, correctIndex, explain:"x += n ist √§quivalent zu x = x + n."}));
    }
  }
  return qs;
}

/** Topic: if without braces / control flow */
function genIf(n) {
  const qs = [];
  for (let i=0;i<n;i++){
    const x = (i%2===0) ? 10 : 0;
    const cond = (i%3===0) ? "x < 5" : "x > 5";
    const condTrue = eval(`${x} ${cond.replace("x","")}`); // safe: only > or <
    const code =
`int x = ${x};

if (${cond})
    System.out.print("A");
System.out.print("B");`;
    const correct = (condTrue ? "AB" : "B");
    const {options, correctIndex} = mkSingleCorrectOptions(correct, ["A","BA","Keine Ausgabe"]);
    qs.push(mkQ({
      title:"Welche Ausgabe wird erzeugt?",
      code,
      options,
      correctIndex,
      explain:"Ohne {} geh√∂rt nur die n√§chste Anweisung zur if. Die zweite Ausgabe kommt immer."
    }));
  }
  return qs;
}

/** Topic: Arrays 1D indexing + length + out of bounds */
function genArrays1D(n) {
  const qs = [];
  for (let i=0;i<n;i++){
    const a0 = 3 + (i%7);
    const a1 = 5 + (i%9);
    const ask = i % 3;

    if (ask === 0) {
      const code = `int[] a = {${a0}, ${a1}};\nSystem.out.println(a[1]);`;
      const {options, correctIndex} = mkSingleCorrectOptions(String(a1), [String(a0), "2", "Compilerfehler"]);
      qs.push(mkQ({title:"Was kommt raus?", code, options, correctIndex, explain:"Arrays sind 0-basiert: a[0]=erstes Element, a[1]=zweites Element."}));
    } else if (ask === 1) {
      const code = `int[] a = {${a0}, ${a1}};\nSystem.out.println(a.length);`;
      const {options, correctIndex} = mkSingleCorrectOptions("2", [String(a0), String(a1), "Compilerfehler"]);
      qs.push(mkQ({title:"Was kommt raus?", code, options, correctIndex, explain:"a.length ist die Anzahl Elemente im Array (hier 2)."}));
    } else {
      const code = `int[] a = {${a0}, ${a1}};\nSystem.out.println(a[2]);`;
      const {options, correctIndex} = mkSingleCorrectOptions("Exception", [String(a0), String(a1), "Compilerfehler"]);
      qs.push(mkQ({title:"Was passiert?", code, options, correctIndex, explain:"Index 2 ist au√üerhalb (g√ºltig: 0..1) ‚Üí Laufzeit-Exception (IndexOutOfBounds)."}));
    }
  }
  return qs;
}

/** Topic: Arrays 2D / jagged / out of bounds */
function genArrays2D(n) {
  const qs = [];
  for (let i=0;i<n;i++){
    const rows = 2 + (i%4); // 2..5
    const kind = i % 3;

    if (kind === 0) {
      // jagged creation
      const code =
`int[][] arr = new int[3][];
arr[0] = new int[1];
arr[1] = new int[2];
arr[2] = new int[3];`;
      const {options, correctIndex} = mkSingleCorrectOptions("Asymmetrisches (jagged) Array", ["Symmetrisches Array","Compilerfehler","Exception"]);
      qs.push(mkQ({title:"Was wird erzeugt?", code, options, correctIndex, explain:"Unterschiedliche Zeilenl√§ngen ‚Üí asymmetrisch (jagged)."}));
    } else if (kind === 1) {
      const code =
`int[][] m = new int[${rows}][3];
System.out.println(m.length);`;
      const {options, correctIndex} = mkSingleCorrectOptions(String(rows), ["3","0","Compilerfehler"]);
      qs.push(mkQ({title:"Was kommt raus?", code, options, correctIndex, explain:"m.length ist die Anzahl Zeilen (erste Dimension)."}));
    } else {
      const code =
`int[][] arr = new int[3][];
arr[3] = new int[1];`;
      const {options, correctIndex} = mkSingleCorrectOptions("Exception", ["OK","Compilerfehler","Asymmetrisches Array"]);
      qs.push(mkQ({title:"Was passiert?", code, options, correctIndex, explain:"arr hat L√§nge 3 ‚Üí g√ºltige Indizes 0..2. arr[3] ‚Üí IndexOutOfBounds-Exception."}));
    }
  }
  return qs;
}

/** Topic: Type system / literals / casting */
function genTypesAndCasting(n) {
  const qs = [];
  const primitives = [
    {q:'Welchen Datentyp hat "128"?', a:"String", wrong:["byte","short","int"], ex:'"..." ist ein String-Literal.'},
    {q:"Welchen Datentyp hat '7'?", a:"char", wrong:["String","int","boolean"], ex:"'7' ist ein Zeichenliteral ‚Üí char."},
    {q:"Welche Aussage ist korrekt?", a:"Integer ist Wrapper-Klasse f√ºr int", wrong:["int ist Wrapper-Klasse f√ºr Integer","String ist primitiv","double ist Klasse"], ex:"Wrapper: Integer f√ºr int."},
  ];
  for (let i=0;i<n;i++){
    if (i % 2 === 0) {
      const a = 1 + (i%9);
      const b = 0.5 + ((i%7) * 0.5); // 0.5..3.5
      const sum = a + b;
      const correct = Math.trunc(sum);
      const code =
`int a = ${a};
double b = ${b};
int c = (int)(a + b);
System.out.println(c);`;
      const {options, correctIndex} = mkSingleCorrectOptions(String(correct), [String(correct+1), String(sum), "Compilerfehler"]);
      qs.push(mkQ({title:"Welche Ausgabe ist korrekt?", code, options, correctIndex, explain:"(int) cast schneidet Nachkommastellen ab (kein Runden)."}));
    } else {
      const p = primitives[i % primitives.length];
      const {options, correctIndex} = mkSingleCorrectOptions(p.a, p.wrong);
      qs.push(mkQ({title:p.q, options, correctIndex, explain:p.ex}));
    }
  }
  return qs;
}

/** Topic: Boolean operators (& | ^ && ||) */
function genBooleanLogic(n) {
  const qs = [];
  const bools = [true,false];
  for (let i=0;i<n;i++){
    const a = bools[i % 2];
    const b = bools[(i+1) % 2];
    const c = bools[(i+2) % 2];
    const kind = i % 4;

    let expr, correct;
    if (kind === 0) { expr = `${a} | ${b}`; correct = (a | b); }
    else if (kind === 1) { expr = `${a} & ${b}`; correct = (a & b); }
    else if (kind === 2) { expr = `${a} ^ ${b}`; correct = (a ^ b); }
    else { expr = `${a} || (${b} & ${c})`; correct = (a || (b & c)); }

    const correctText = correct ? "true" : "false";
    const {options, correctIndex} = mkSingleCorrectOptions(correctText, [correct ? "false":"true", "Compilerfehler", "0"]);
    qs.push(mkQ({
      title:`Ergebnis (true/false): ${expr}`,
      options, correctIndex,
      explain:"Bei boolean: | & ^ sind erlaubt. && und || sind Kurzschluss-Operatoren; & und | werten beide Seiten aus."
    }));
  }
  return qs;
}

/** Topic: Ternary operator */
function genTernary(n) {
  const qs = [];
  for (let i=0;i<n;i++){
    const z = (i%3===0) ? 0 : (i%2===0 ? 5 : -4);
    const out = (z>0) ? "positiv" : (z<0 ? "negativ" : "null");
    const code =
`int zahl = ${z};
System.out.println(zahl > 0 ? "positiv" : zahl < 0 ? "negativ" : "null");`;
    const {options, correctIndex} = mkSingleCorrectOptions(out, ["positiv","negativ","null"].filter(x=>x!==out));
    qs.push(mkQ({title:"Welche Ausgabe entsteht?", code, options, correctIndex, explain:"Verschachtelter tern√§rer Operator: >0, sonst <0, sonst null."}));
  }
  return qs;
}

/** Topic: Semiotik */
function genSemiotics(n) {
  const qs = [];
  const items = [
    {q:"In welche semiotische Kategorie f√§llt die Einr√ºckung des Quelltexts?", a:"Pragmatik", wrong:["Lexikalik","Syntax","Semantik"], ex:"Einr√ºckung ist f√ºr Lesbarkeit/Kommunikation (Menschen) ‚Üí Pragmatik."},
    {q:"Zu welcher Kategorie geh√∂rt die Bedeutung eines Programms?", a:"Semantik", wrong:["Syntax","Lexikalik","Pragmatik"], ex:"Semantik = Bedeutung/Verhalten."},
    {q:"Zu welcher Kategorie geh√∂rt die Struktur/Grammatik eines Programms?", a:"Syntax", wrong:["Semantik","Pragmatik","Lexikalik"], ex:"Syntax = formale Regeln."},
    {q:"Zu welcher Kategorie geh√∂ren Tokens/Schl√ºsselw√∂rter (z.B. if, int)?", a:"Lexikalik", wrong:["Semantik","Syntax","Pragmatik"], ex:"Lexikalik = Tokenisierung, Schl√ºsselw√∂rter, Bezeichner."}
  ];
  for (let i=0;i<n;i++){
    const it = items[i % items.length];
    const {options, correctIndex} = mkSingleCorrectOptions(it.a, it.wrong);
    qs.push(mkQ({title:it.q, options, correctIndex, explain:it.ex}));
  }
  return qs;
}

/** Topic: Methods / return / overloading / getters-setters basics (MC style) */
function genMethodsOOP(n) {
  const qs = [];
  const base = [
    {q:"Wie viele return-Anweisungen darf eine Methode enthalten?", a:"Beliebig viele", wrong:["Genau eine","Keine","Genau zwei"], ex:"Mehrere returns sind erlaubt (z.B. in if/else)."},
    {q:"Welche Voraussetzung gilt f√ºr Methoden√ºberladung?", a:"Andere Parameterliste", wrong:["Nur anderer R√ºckgabewert","Nur anderer Methodenname","Nur anderer Sichtbarkeitsmodifikator"], ex:"Overloading: gleicher Name, aber andere Parameterliste (Typ/Anzahl/Reihenfolge)."},
    {q:"Welche Sichtbarkeit erlaubt Zugriff nur innerhalb der Klasse?", a:"private", wrong:["public","protected","package-private"], ex:"private kapselt auf Klassenebene."},
    {q:"Wof√ºr steht this typischerweise?", a:"Verweis auf aktuelles Objekt", wrong:["Verweis auf Oberklasse","Erzeugt neues Objekt","Beendet Methode"], ex:"this referenziert die aktuelle Instanz."},
    {q:"Welche Zeile erzeugt ein Objekt der Klasse Auto?", a:"Auto a = new Auto();", wrong:["Auto a;","new Auto;","Auto = new a();"], ex:"Objekterzeugung: new + Konstruktoraufruf."},
    {q:"Welche Aussage zu static ist korrekt?", a:"static geh√∂rt zur Klasse", wrong:["static geh√∂rt zur Instanz","static braucht immer ein Objekt","static verhindert Vererbung"], ex:"static ist klassenweit."},
    {q:"Welcher Getter ist korrekt f√ºr private int punkte;", a:"public int getPunkte(){ return punkte; }",
      wrong:["public void getPunkte(){ return punkte; }","public int getPunkte(int p){ return p; }","public int getPunkte(){ return this; }"],
      ex:"Getter: R√ºckgabetyp passt, keine Parameter, return Feld."},
    {q:"Welcher Setter ist korrekt f√ºr private int punkte;", a:"public void setPunkte(int punkte){ this.punkte = punkte; }",
      wrong:["public int setPunkte(int punkte){ return this.punkte; }","public void setPunkte(){ this.punkte = punkte; }","public void setPunkte(int p){ punkte = this.p; }"],
      ex:"Setter: void, Parameter, Zuweisung this.feld = parameter."},
  ];
  for (let i=0;i<n;i++){
    const b = base[i % base.length];
    const {options, correctIndex} = mkSingleCorrectOptions(b.a, b.wrong);
    qs.push(mkQ({title:b.q, options, correctIndex, explain:b.ex}));
  }
  return qs;
}

/** Topic: JOptionPane parsing (MC) */
function genParsing(n) {
  const qs = [];
  const base = [
    {q:"Welche Methode konvertiert einen String in einen int?", a:"Integer.parseInt(s)", wrong:["Integer.toString(s)","Double.parseInt(s)","String.valueOf(int)"], ex:"Integer.parseInt(String) ‚Üí int."},
    {q:"Welche Methode konvertiert einen String in einen double?", a:"Double.parseDouble(s)", wrong:["Double.toDouble(s)","Integer.parseDouble(s)","Math.double(s)"], ex:"Double.parseDouble(String) ‚Üí double."},
    {q:"Was macht (int)(zahl1 + zahl2) bei Nachkommastellen?", a:"Schneidet Nachkommastellen ab", wrong:["Rundet automatisch","Erzeugt String","Compilerfehler"], ex:"(int) cast trunciert (kein Runden)."},
  ];
  for (let i=0;i<n;i++){
    const b = base[i % base.length];
    const {options, correctIndex} = mkSingleCorrectOptions(b.a, b.wrong);
    qs.push(mkQ({title:b.q, options, correctIndex, explain:b.ex}));
  }
  return qs;
}

  /** Topic: ArrayList (Java Collections Basics) */
function genArrayList(n) {
  const qs = [];
  const base = [
    {
      q: "Welche Zeile erzeugt eine ArrayList f√ºr Integers korrekt?",
      a: "ArrayList<Integer> list = new ArrayList<>();",
      wrong: [
        "ArrayList<int> list = new ArrayList<>();",
        "ArrayList list = new ArrayList<int>();",
        "ArrayList<Integer> list = new ArrayList<int>();"
      ],
      ex: "Generics brauchen Referenztypen (Integer statt int). Diamond-Operator <> ist erlaubt."
    },
    {
      q: "Was liefert list.size()?",
      a: "Anzahl der Elemente in der Liste",
      wrong: ["Maximale Kapazit√§t der Liste", "Letzten Index der Liste", "Immer die L√§nge 0..n-1"],
      ex: "size() = Elementanzahl (kann sich √§ndern)."
    },
    {
      q: "Welche Aussage ist korrekt?",
      a: "ArrayList ist dynamisch vergr√∂√üerbar",
      wrong: ["ArrayList hat feste L√§nge wie ein Array", "ArrayList speichert nur primitive Typen", "ArrayList ist automatisch sortiert"],
      ex: "ArrayList w√§chst dynamisch; Sortierung nur mit zus√§tzlicher Logik (z.B. Collections.sort)."
    },
    {
      q: "Wie greifst du auf das 1. Element zu?",
      a: "list.get(0)",
      wrong: ["list[0]", "list.get(1)", "list.first()"],
      ex: "Index ist 0-basiert; Zugriff via get(index)."
    },
    {
      q: "Was macht list.add(x)?",
      a: "F√ºgt x am Ende hinzu",
      wrong: ["Ersetzt das erste Element", "L√∂scht x, falls vorhanden", "Sortiert die Liste automatisch"],
      ex: "add(E) h√§ngt ans Ende (oder add(index,E) an Position)."
    },
    {
      q: "Was passiert bei list.get(i) mit i au√üerhalb des Bereichs?",
      a: "Exception",
      wrong: ["Compilerfehler", "Gibt null zur√ºck", "Gibt 0 zur√ºck"],
      ex: "Out-of-range ‚Üí IndexOutOfBoundsException zur Laufzeit."
    },
    {
      q: "Welche Schleife ist typisch, um alle Elemente zu durchlaufen?",
      a: "for (int i=0; i<list.size(); i++)",
      wrong: ["for (int i=0; i<=list.size(); i++)", "while(list.hasNext())", "loop(list)"],
      ex: "Bedingung ist i < size(), nicht <=."
    },
    {
      q: "Welche Aussage zu remove ist korrekt?",
      a: "remove(int index) l√∂scht an Position index",
      wrong: ["remove(int index) l√∂scht den Wert index immer als Element", "remove() gibt boolean zur√ºck", "remove l√∂scht nie, sondern markiert nur"],
      ex: "√úberladung: remove(index) vs remove(Object). Bei Integer kann das tricky sein."
    }
  ];

  for (let i = 0; i < n; i++) {
    const b = base[i % base.length];

    // kleine Variation: bei jeder 2. Frage Code-Variante statt reinem Text
    if (i % 2 === 0 && b.q.includes("ArrayList")) {
      const title = "Welche Zeile ist korrekt?";
      const code = `import java.util.*;\n\n// ...\n// W√§hle die richtige Initialisierung`;
      const { options, correctIndex } = mkSingleCorrectOptions(b.a, b.wrong);
      qs.push(mkQ({ title, code, options, correctIndex, explain: b.ex }));
    } else {
      const { options, correctIndex } = mkSingleCorrectOptions(b.a, b.wrong);
      qs.push(mkQ({ title: b.q, options, correctIndex, explain: b.ex }));
    }
  }
  return qs;
}

/** Topic: Transfer / SE-Grundlagen (aus deinen 5 Textfragen) */
function genTransferSE(n) {
  const qs = [];
  const base = [
    // Frage 1: Lastenheft vs Pflichtenheft
    {
      q: "Lastenheft: Perspektive?",
      a: "Auftraggeber",
      wrong: ["Auftragnehmer", "Tester", "Entwicklerteam"],
      ex: "Lastenheft beschreibt WAS das System leisten soll ‚Äì aus Auftraggeber-Sicht."
    },
    {
      q: "Pflichtenheft: Perspektive?",
      a: "Auftragnehmer",
      wrong: ["Auftraggeber", "Nutzer", "Projektcontrolling"],
      ex: "Pflichtenheft beschreibt WIE Anforderungen umgesetzt werden ‚Äì aus Auftragnehmer-Sicht."
    },
    {
      q: "Welche 3 Elemente passen typischerweise ins Lastenheft?",
      a: "Projektbeschreibung + Anforderungen + Rahmenbedingungen",
      wrong: [
        "Systemarchitektur + technische Umsetzung + Change-Management",
        "Unit-Tests + Integrationstests + Abnahmetests",
        "Code-Struktur + Klassenhierarchie + Methodenliste"
      ],
      ex: "Lastenheft: funktionale/nicht-funktionale Anforderungen + organisatorischer Rahmen (z.B. Budget/Einschr√§nkungen)."
    },
    {
      q: "Welche 3 Elemente passen typischerweise ins Pflichtenheft?",
      a: "Systemarchitektur + technische Umsetzung + Zeit/Projektplan",
      wrong: [
        "W√ºnsche/Ziele + grobe Idee + Marketingstrategie",
        "Budget + Einschr√§nkungen + Projektbeschreibung",
        "Stakeholderliste + Persona + Customer Journey"
      ],
      ex: "Pflichtenheft: Architektur, technische Umsetzung, Zeit-/Projektplan inkl. Change-Management."
    },

    // Frage 2: Top-Down vs Bottom-Up
    {
      q: "Top-Down beginnt typischerweise womit?",
      a: "√úbergeordneten Anforderungen",
      wrong: ["Konkreten Details", "Unit-Tests", "Datenbanktabellen"],
      ex: "Top-Down: vom Groben ins Detail; danach Validierung."
    },
    {
      q: "Bottom-Up beginnt typischerweise womit?",
      a: "Konkreten Details/Modulen",
      wrong: ["Vision/Strategie", "Pflichtenheft", "Grobkonzept"],
      ex: "Bottom-Up: Details ‚Üí Module ‚Üí Gesamtanforderungen; danach Validierung."
    },

    // Frage 3: Vorgehensmodelle
    {
      q: "Wasserfallmodell ist am besten beschrieben als ‚Ä¶",
      a: "Sequenziell: Phasen nacheinander",
      wrong: ["Iterativ: kurze Zyklen", "Parallel: alle Phasen gleichzeitig", "Ohne Tests"],
      ex: "Wasserfall: Analyse ‚Üí Entwurf ‚Üí Implementierung ‚Üí Test (streng nacheinander)."
    },
    {
      q: "Was ist der Kern-Unterschied V-Modell vs Wasserfall?",
      a: "Jeder Entwicklungsphase ist eine Testphase zugeordnet",
      wrong: ["Es gibt keine Tests", "Es ist immer agil", "Es hat keine Phasen"],
      ex: "V-Modell koppelt Entwicklung + passende Testphase f√ºr Qualit√§t/Nachvollziehbarkeit."
    },
    {
      q: "Agil bedeutet hier prim√§r ‚Ä¶",
      a: "Iterationen + flexible Anpassung + kontinuierlich lauff√§hige Software",
      wrong: ["Nur einmal liefern am Ende", "Keine Dokumentation erlaubt", "Phasen strikt nacheinander"],
      ex: "Agil: kurze Zyklen, Feedback, Anpassung, laufende Inkremente."
    },

    // Frage 4: Schwierigkeiten Anforderungsanalyse
    {
      q: "Welche Schwierigkeit ist typisch in der Anforderungsanalyse?",
      a: "Kunde benennt Anforderungen unkonkret (nur W√ºnsche/Ziele)",
      wrong: ["Anforderungen sind immer vollst√§ndig", "Fachleute sind immer verf√ºgbar", "Es gibt nie √Ñnderungen"],
      ex: "Oft fehlen konkrete Anforderungen; nur Ziele/W√ºnsche werden ge√§u√üert."
    },
    {
      q: "Was meint man mit 'hidden agenda' im Kontext Anforderungsanalyse?",
      a: "Beteiligte verzerren Anforderungen bewusst/unbewusst",
      wrong: ["Es gibt geheime Passw√∂rter", "Der Code ist verschl√ºsselt", "Das Lastenheft ist automatisch korrekt"],
      ex: "Analyseteam/Kunde k√∂nnen Interessen verfolgen und Anforderungen verzerren."
    },
    {
      q: "Welche Aussage ist korrekt?",
      a: "Selbstverst√§ndliche Anforderungen werden oft nicht erw√§hnt",
      wrong: ["Selbstverst√§ndliches wird immer explizit genannt", "Nicht-funktionale Anforderungen gibt es nicht", "√Ñnderungen kommen nur am Anfang vor"],
      ex: "Viele Anforderungen gelten als 'klar' und werden nicht ausgesprochen ‚Äì Risiko f√ºr Missverst√§ndnisse."
    },

    // Frage 5: Methoden Software Engineering
    {
      q: "Heuristische Methoden sind ‚Ä¶",
      a: "Erfahrungsbasierte Analyse-/Entwurfstechniken (z.B. OO-Modellierung)",
      wrong: ["Mathematisch formal bewiesen", "Nur Prototypen ohne Struktur", "Reine Code-Formatierung"],
      ex: "Heuristisch = praxis-/erfahrungsbasiert, strukturiert modellieren/entwerfen."
    },
    {
      q: "Formale Methoden nutzen ‚Ä¶",
      a: "Mathematisch pr√§zise Spezifikationen zur Pr√ºfung von Konsistenz/Korrektheit",
      wrong: ["Nur Bauchgef√ºhl", "Nur UI-Mockups", "Nur Scrum-Meetings"],
      ex: "Formal = mathematische Spezifikation + formale Verifikation."
    },
    {
      q: "Prototyping dient haupts√§chlich wozu?",
      a: "Fr√ºhes Feedback + Validierung von Anforderungen/Funktionen",
      wrong: ["Finale Version direkt ersetzen", "Tests komplett vermeiden", "Nur Dokumentation erzeugen"],
      ex: "Prototypen: fr√ºh, unvollst√§ndig, zum Testen/Validieren/Feedback."
    }
  ];

  for (let i = 0; i < n; i++) {
    const b = base[i % base.length];
    const { options, correctIndex } = mkSingleCorrectOptions(b.a, b.wrong);
    qs.push(mkQ({ title: b.q, options, correctIndex, explain: b.ex }));
  }
  return qs;
}


/** ---------- Build (expandable) ---------- **/
function buildCatalog() {
  const = [];

  // Base (dein bisheriger 500er Pool)
  catalog.push(...genTools(40));
  catalog.push(...genArithmetic(120));
  catalog.push(...genIncrement(80));
  catalog.push(...genIf(60));
  catalog.push(...genArrays1D(60));
  catalog.push(...genArrays2D(40));
  catalog.push(...genTypesAndCasting(40));
  catalog.push(...genBooleanLogic(30));
  catalog.push(...genTernary(10));
  catalog.push(...genSemiotics(10));
  catalog.push(...genMethodsOOP(8));
  catalog.push(...genParsing(2));

  // NEW: ArrayList + Transfer (Beispiel: +120 Fragen)
  catalog.push(...genArrayList(80));
  catalog.push(...genTransferSE(120));

  // Kein hartes 500-Limit mehr ‚Äì aber Mindestcheck
  assert(catalog.length >= 500, `Katalog ist zu klein: ${catalog.length}`);
  return catalog;
}

/** ---------- Validation (hard gate) ---------- **/
function validateCatalog(catalog) {
  const seenIds = new Set();
  catalog.forEach((q, idx) => {
    assert(typeof q.id === "number", `Frage ${idx}: id fehlt/ung√ºltig.`);
    assert(!seenIds.has(q.id), `Doppelte id: ${q.id}`);
    seenIds.add(q.id);

    assert(typeof q.title === "string" && q.title.trim().length > 0, `Frage ${q.id}: title fehlt.`);
    assert(Array.isArray(q.options) && q.options.length === 4, `Frage ${q.id}: options muss L√§nge 4 haben.`);
    assert(q.options.every(o => typeof o === "string"), `Frage ${q.id}: options m√ºssen Strings sein.`);
    assert(uniq(q.options).length === 4, `Frage ${q.id}: options enthalten Duplikate.`);
    assert(Number.isInteger(q.correctIndex) && q.correctIndex >= 0 && q.correctIndex < 4, `Frage ${q.id}: correctIndex ung√ºltig.`);
    assert(typeof q.explain === "string" && q.explain.trim().length > 0, `Frage ${q.id}: explain fehlt.`);
    // Optional sanity: forbid empty distractors
    assert(q.options.every(o => o.trim().length > 0), `Frage ${q.id}: leere Option.`);
  });
}

/** ---------- Quiz Engine ---------- **/
const QUIZ_SIZE = 12;
let = [];
let quiz = [];
let idx = 0;
let score = 0;
let answered = false;
let wrongLog = [];

function buildNewQuiz(fromQuestions) {
  const base = fromQuestions ?? CATALOG;
  const picked = sampleUnique(base, Math.min(QUIZ_SIZE, base.length)).map(withShuffledOptions);
  return picked;
}

function reset(mode = "new") {
  if (mode === "wrong") {
    const wrongQuestions = wrongLog.map(w => w.original);
    const src = wrongQuestions.length ? wrongQuestions : CATALOG;
    quiz = buildNewQuiz(src);
  } else {
    quiz = buildNewQuiz(CATALOG);
  }

  idx = 0;
  score = 0;
  answered = false;
  wrongLog = [];

  el("score").textContent = score;
  el("qTotal").textContent = quiz.length;
  el("result").style.display = "none";
  el("quizCard").style.display = "block";
  render();
}

function render() {
  const q = quiz[idx];
  el("qIndex").textContent = idx + 1;
  el("bar").style.width = `${(idx / quiz.length) * 100}%`;

  el("qTitle").textContent = q.title;

  if (q.code) {
    el("qCode").style.display = "block";
    el("qCode").textContent = q.code;
  } else {
    el("qCode").style.display = "none";
    el("qCode").textContent = "";
  }

  const optionsDiv = el("options");
  optionsDiv.innerHTML = "";

  q.shuffledOptions.forEach((opt, i) => {
    const label = document.createElement("label");
    label.className = "opt";
    label.setAttribute("data-index", String(i));

    const radio = document.createElement("input");
    radio.type = "radio";
    radio.name = "answer";
    radio.value = String(i);
    radio.addEventListener("change", () => {
      if (!answered) el("checkBtn").disabled = false;
    });

    const span = document.createElement("span");
    span.textContent = opt;

    label.appendChild(radio);
    label.appendChild(span);
    optionsDiv.appendChild(label);
  });

  answered = false;
  el("checkBtn").disabled = true;
  el("nextBtn").disabled = true;
  el("feedback").style.display = "none";
  el("feedback").className = "feedback";
  el("fbTitle").textContent = "";
  el("fbText").textContent = "";
}

function getSelectedIndex() {
  const checked = document.querySelector('input[name="answer"]:checked');
  return checked ? Number(checked.value) : null;
}

function markOptions(correctIndex, selectedIndex) {
  const optionEls = document.querySelectorAll(".opt");
  optionEls.forEach((optEl) => {
    const i = Number(optEl.getAttribute("data-index"));
    optEl.classList.remove("correct", "wrong");
    if (i === correctIndex) optEl.classList.add("correct");
    if (selectedIndex !== null && i === selectedIndex && selectedIndex !== correctIndex) {
      optEl.classList.add("wrong");
    }
    const input = optEl.querySelector("input");
    if (input) input.disabled = true;
  });
}

function check() {
  if (answered) return;
  const q = quiz[idx];
  const sel = getSelectedIndex();
  if (sel === null) return;

  answered = true;
  const ok = sel === q.shuffledCorrectIndex;
  if (ok) score += 1;
  else {
    wrongLog.push({
      original: {
        id: q.id, title: q.title, code: q.code,
        options: q.options, correctIndex: q.correctIndex, explain: q.explain
      },
      n: idx + 1,
      your: q.shuffledOptions[sel],
      right: q.shuffledOptions[q.shuffledCorrectIndex],
      explain: q.explain
    });
  }

  el("score").textContent = score;
  markOptions(q.shuffledCorrectIndex, sel);

  el("feedback").style.display = "block";
  el("feedback").classList.add(ok ? "ok" : "no");
  el("fbTitle").textContent = ok ? "‚úÖ Richtig" : "‚ùå Falsch";
  el("fbText").textContent = q.explain;

  el("nextBtn").disabled = false;
}

function next() {
  if (!answered) return;
  idx += 1;
  if (idx >= quiz.length) finish();
  else render();
}

function finish() {
  el("bar").style.width = "100%";
  el("quizCard").style.display = "none";
  el("result").style.display = "block";

  const total = quiz.length;
  const percent = Math.round((score / total) * 100);
  el("resultText").textContent =
    `Du hast ${score} von ${total} Punkten (${percent}%). Pool: ${CATALOG.length} Fragen ‚Ä¢ Pro Quiz: ${QUIZ_SIZE} (random)`;

  const review = el("review");
  review.innerHTML = "";

  if (wrongLog.length === 0) {
    const div = document.createElement("div");
    div.className = "item";
    div.innerHTML = `<strong>Stark.</strong> Keine falschen Antworten. N√§chster Step: Tempo hoch oder Klausurmodus erg√§nzen.`;
    review.appendChild(div);
    return;
  }

  wrongLog.forEach((w) => {
    const div = document.createElement("div");
    div.className = "item";
    const codeBlock = w.original.code ? `<pre>${escapeHtml(w.original.code)}</pre>` : "";
    div.innerHTML = `
      <strong>Frage ${w.n}:</strong> ${escapeHtml(w.original.title)}<br/>
      ${codeBlock}
      <div class="small"><b>Deine Antwort:</b> ${escapeHtml(w.your)}</div>
      <div class="small"><b>Richtig:</b> ${escapeHtml(w.right)}</div>
      <div class="small"><b>Warum:</b> ${escapeHtml(w.explain)}</div>
    `;
    review.appendChild(div);
  });
}

/** ---------- Wiring ---------- **/
el("checkBtn").addEventListener("click", check);
el("nextBtn").addEventListener("click", next);
el("restartBtn").addEventListener("click", () => reset("new"));
el("restartBtn2").addEventListener("click", () => reset("new"));
el("reviewOnlyWrongBtn").addEventListener("click", () => reset("wrong"));

/** ---------- Boot ---------- **/
(function boot(){
  try {
    CATALOG = buildCatalog();
    validateCatalog(CATALOG);
    el("poolSize").textContent = String(CATALOG.length);
    reset("new");
  } catch (e) {
    // Hard fail: do NOT run quiz with broken catalog
    const box = el("fatal");
    box.style.display = "block";
    box.textContent = "üö® Quiz-Start gestoppt: " + (e?.message || String(e));
    el("quizCard").style.display = "none";
  }
})();
</script>
</body>
</html>
